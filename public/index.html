<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>COGgpt — Research Q&A</title>
  <link rel="stylesheet" href="/styles.css" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <style>
    /* keep your existing styles.css; these are tiny helpers only */
    .header { position: relative; align-items: center; display:flex; justify-content: space-between; }
    .beta-badge { position:absolute; right:0; top:0; color:#b9b9b9; font-weight:700; letter-spacing:.08em; font-size:14px; }
    .charts-grid { display:grid; grid-template-columns: repeat(auto-fit,minmax(280px,1fr)); gap:16px; }
    .chart-card { background:#fff; border-radius:12px; padding:16px; box-shadow:0 2px 10px rgba(0,0,0,.06); height:260px; }
    .chart-card h4 { margin:0 0 8px 0; font-size:14px; color:#333; }
    .muted { color:#666; font-size:12px; }
    .quote-wrap { display:block; }
    .quote-item { margin:0 0 14px 0; }
    .quote-text { font-style: italic; margin:0; }
    .quote-tag { margin-top:4px; font-size: 0.85em; color:#333; }
    .ref-list { display:grid; grid-template-columns: repeat(auto-fit,minmax(260px,1fr)); gap:12px; }
    .ref-item { background:#fff; border-radius:12px; padding:14px; box-shadow:0 2px 10px rgba(0,0,0,.06); }
    .ref-item a { text-decoration:none; color:#0b6bcb; }
  </style>
</head>
<body>
  <div class="page">

    <!-- Header -->
    <header class="header">
      <h1 class="title">COG<span style="color:#ff7a00;">gpt</span></h1>
      <!-- Removed company logo on the right; keeping a subtle BETA badge -->
      <div class="beta-badge">BETA</div>
    </header>

    <!-- Search -->
    <section class="search">
      <form id="qform">
        <input id="q" type="text" placeholder="ask a question about your research…" autocomplete="off"
               value="What are the barriers to treatment for untreated patients?" />
        <button id="ask" type="submit">Ask</button>
      </form>
    </section>

    <!-- Answer -->
    <section id="answer" class="callout" style="display:none;"></section>

    <!-- Supporting Detail (bullets; no trailing periods) -->
    <section class="panel">
      <h3>Supporting Detail</h3>
      <ul id="bullets"></ul>
    </section>

    <!-- Supporting Quotes (no bullets; italic quotes + respondent tag under) -->
    <section class="panel">
      <h3>Supporting Quotes</h3>
      <div id="quotes" class="quote-wrap"></div>
    </section>

    <!-- Visuals (charts only) -->
    <section class="panel">
      <h3>Visuals</h3>
      <div id="charts" class="charts-grid"></div>
      <p id="chartNote" class="muted" style="display:none;">Auto‑generated visuals from extracted numbers.</p>
    </section>

    <!-- Report References -->
    <section class="panel">
      <h3>Report References</h3>
      <div id="refs" class="ref-list"></div>
    </section>
  </div>

  <script>
    // ---------- helpers ----------
    const has = (o, k) => Object.prototype.hasOwnProperty.call(o || {}, k);

    function cleanOuterQuotes(s) {
      if (!s) return "";
      return String(s).trim().replace(/^["“]+/, "").replace(/["”]+$/, "");
    }
    function stripFinalPeriodForBullets(s) {
      return String(s || "").trim().replace(/[.。]\s*$/, "");
    }
    function niceTitle(s) { return (s || "").replace(/_/g, " "); }
    function slideLink(url, slideIndex) {
      if (!url) return "#";
      if (typeof slideIndex === "number") {
        const sep = url.includes("?") ? "&" : "?";
        return `${url}${sep}slide=${slideIndex + 1}`;
      }
      return url;
    }
    function humanSlideLabel(ref) {
      if (typeof ref.slideIndex === "number") return `Slide ${ref.slideIndex + 1}`;
      if (typeof ref.page === "number" && ref.page > 1) return `p.${ref.page}`;
      return "";
    }
    function splitQuoteAndTag(s) {
      const txt = cleanOuterQuotes(s);
      const m = txt.match(/^(.*?)(?:\s*[–—-]\s*(.+))?$/);
      return { quote: (m ? m[1] : txt).trim(), tag: (m && m[2] ? m[2] : "").trim() };
    }
    function el(tag, attrs = {}, children = []) {
      const node = document.createElement(tag);
      for (const [k, v] of Object.entries(attrs)) {
        if (k === "class") node.className = v;
        else if (k === "html") node.innerHTML = v;
        else node.setAttribute(k, v);
      }
      [].concat(children).forEach(c => node.appendChild(typeof c === "string" ? document.createTextNode(c) : c));
      return node;
    }

    // ---------- renderers ----------
    function renderAnswer(text) {
      const box = document.getElementById("answer");
      box.textContent = text || "No answer.";
      box.style.display = "block";
    }
    function renderBullets(items = []) {
      const ul = document.getElementById("bullets"); ul.innerHTML = "";
      if (!items.length) return;
      items.forEach(x => ul.appendChild(el("li", {}, stripFinalPeriodForBullets(x))));
    }
    function renderQuotes(items = []) {
      const wrap = document.getElementById("quotes"); wrap.innerHTML = "";
      if (!items.length) { wrap.appendChild(el("div",{class:"muted"},"No quotes returned.")); return; }
      items.forEach(item => {
        let text="", tag="";
        if (item && typeof item === "object") { text = item.text || item.quote || ""; tag = item.tag || item.respondent || ""; }
        else { text = String(item || ""); }
        const parsed = splitQuoteAndTag(text);
        if (!tag) tag = parsed.tag;

        const block = el("div", { class: "quote-item" });
        block.appendChild(el("p", { class: "quote-text" }, parsed.quote));
        if (tag) block.appendChild(el("div", { class: "quote-tag" }, "— " + tag));
        wrap.appendChild(block);
      });
    }
    function renderCharts(visuals = [], maxCharts = 4) {
      const grid = document.getElementById("charts");
      const note = document.getElementById("chartNote");
      grid.innerHTML = "";
      let drawn = 0;

      visuals.slice(0, maxCharts).forEach(series => {
        if (!series || !Array.isArray(series.points) || series.points.length < 2) return;
        const labels = series.points.map(p => p.x);
        const values = series.points.map(p => Number(p.y));

        const card = el("div", { class: "chart-card" });
        card.appendChild(el("h4", {}, series.title || "Chart"));
        const canvas = el("canvas"); card.appendChild(canvas);
        grid.appendChild(card);

        new Chart(canvas.getContext("2d"), {
          type: (series.type === "bar" ? "bar" : "line"),
          data: { labels, datasets: [{ label: series.title || "", data: values }] },
          options: {
            responsive: true, maintainAspectRatio: false,
            scales: { y: { beginAtZero: true, ticks: { callback: v => v + "%" } } },
            plugins: { legend: { display: false } }
          }
        });
        drawn++;
      });

      note.style.display = drawn ? "block" : "none";
      if (!drawn) grid.appendChild(el("div",{class:"muted"},"No chartable data found."));
    }
    function renderRefs(refs = []) {
      const list = document.getElementById("refs"); list.innerHTML = "";
      if (!refs.length) { list.appendChild(el("div",{class:"muted"},"No sources returned.")); return; }

      refs.forEach(r => {
        const title = niceTitle(r.fileName || "Report");
        const label = humanSlideLabel(r);
        const url = slideLink(r.fileUrl, r.slideIndex);
        const item = el("div", { class: "ref-item" }, [
          el("a", { href: url, target: "_blank", rel: "noopener" }, title),
          label ? el("div", { class: "muted" }, label) : null,
          r.snippet ? el("div", { class: "muted" }, r.snippet) : null
        ]);
        list.appendChild(item);
      });
    }

    // ---------- fetch/search ----------
    async function runQuery(userQuery) {
      const res = await fetch("/search", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        // DO NOT send x-auth-token from browser; server protects API itself
        body: JSON.stringify({ clientId: "genentech", userQuery, topK: 6 })
      });
      if (!res.ok) throw new Error("Search failed: " + res.status);
      const data = await res.json();

      // tolerant field picks (your backend sometimes varies):
      const answer =
        data.answer ?? data.summary ?? data.result ?? "";
      const bullets =
        data.bullets ?? data.supporting ?? data.keyFindings ?? [];
      const quotes =
        data.quotes ?? data.supportingQuotes ?? [];
      const visuals =
        data.visuals ?? data.charts ?? [];
      const refs =
        data.references ?? data.refs ?? [];

      renderAnswer(answer);
      renderBullets(bullets);
      renderQuotes(quotes);
      renderCharts(visuals);
      renderRefs(refs);
    }

    document.getElementById("qform").addEventListener("submit", async (e) => {
      e.preventDefault();
      const q = document.getElementById("q").value.trim();
      if (!q) return;
      try { await runQuery(q); }
      catch (err) { console.error(err); alert("Search error. See console for details."); }
    });

    // auto-run once for the default value
    window.addEventListener("DOMContentLoaded", () => {
      const q = document.getElementById("q").value.trim();
      if (q) document.getElementById("qform").dispatchEvent(new Event("submit"));
    });
  </script>
</body>
</html>
