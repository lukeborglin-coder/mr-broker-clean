<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>COGgpt — Research Q&A</title>

  <link rel="stylesheet" href="/styles.css" />
  <!-- Auth token for /search; update if you rotate -->
  <meta name="auth-token" content="Jrx4cukgLvuj5jFs4mU0U5ckL+UxHfkrL5pHY+xr5Hw=">
  <!-- Charts (for visuals) -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>
<body>
  <div class="page">

    <!-- Header -->
    <header class="header">
      <h1 class="title">
        <span class="title-cog">COG</span><span class="title-gpt">gpt</span>
      </h1>
      <div class="beta-badge">BETA</div>
    </header>

    <!-- Search -->
    <section class="search">
      <form id="qform" autocomplete="off">
        <textarea id="q" rows="3"
          placeholder="Try: “What has satisfaction for Evrysdi looked like over the past few years?”"></textarea>
        <button id="ask" type="submit" title="Ask">Ask</button>
      </form>
      <div id="inlineErr" class="muted hidden"></div>
    </section>

    <!-- Results (hidden until we have results) -->
    <div id="results" class="results hidden">

      <section id="answer" class="callout" aria-live="polite"></section>

      <section class="panel">
        <h3>Supporting Detail</h3>
        <ul id="bullets"></ul>
      </section>

      <section class="panel">
        <h3>Supporting Quotes</h3>
        <div id="quotes"></div>
      </section>

      <!-- Visuals panel (will be hidden entirely if nothing chartable) -->
      <section id="visualsPanel" class="panel">
        <h3>Visuals</h3>
        <div id="charts" class="charts-grid"></div>
      </section>

      <section class="panel">
        <h3>Report References</h3>
        <div id="refs" class="ref-list"></div>
      </section>
    </div>
  </div>

  <script>
    // ---------- helpers ----------
    const qs  = (s, r=document) => r.querySelector(s);
    const qsa = (s, r=document) => Array.from(r.querySelectorAll(s));
    const has = (o, k) => Object.prototype.hasOwnProperty.call(o || {}, k);
    const show = el => el && el.classList.remove("hidden");
    const hide = el => el && el.classList.add("hidden");

    function el(tag, attrs = {}, children = []) {
      const node = document.createElement(tag);
      for (const [k, v] of Object.entries(attrs)) {
        if (k === "class") node.className = v;
        else if (k === "html") node.innerHTML = v;
        else node.setAttribute(k, v);
      }
      [].concat(children).forEach(c => {
        if (c === null || c === undefined) return;
        node.appendChild(typeof c === "string" ? document.createTextNode(c) : c);
      });
      return node;
    }

    // Footnote marker ^2^ -> <sup>[2]</sup>
    function footnotesToSuperscripts(s) {
      return String(s || "").replace(/\^(\d+)\^/g, (_, n) => `\u00A0[${n}]`);
    }

    // Ensure quotes have ending punctuation (., !, ?)
    function ensureTerminalPunct(s) {
      if (!s) return s;
      const t = String(s).trim();
      return /[.!?]$/.test(t) ? t : (t + ".");
    }

    // Extract respondent tag if present: “ … ” - Tag
    function splitQuoteAndTag(raw) {
      const txt = String(raw || "").trim().replace(/^["“]+/, "").replace(/["”]+$/, "");
      const m = txt.match(/^(.*?)(?:\s*[–—-]\s*(.+))?$/);
      return { quote: (m ? m[1] : txt).trim(), tag: (m && m[2] ? m[2] : "").trim() };
    }

    function niceTitle(s) { return (s || "").replace(/_/g, " "); }

    // ---------- renderers ----------
    function renderAnswer(text) {
      qs("#answer").textContent = text || "No answer.";
    }

    // Keep periods off bullet ends (your earlier preference), but include [n] refs
    function renderBullets(items = []) {
      const ul = qs("#bullets"); ul.innerHTML = "";
      const arr = Array.isArray(items) ? items : [];
      if (!arr.length) { ul.appendChild(el("li",{class:"muted"},"No supporting detail returned.")); return; }
      arr.forEach(x => {
        let t = String(x || "").trim();
        t = footnotesToSuperscripts(t);
        t = t.replace(/[.。]\s*$/, ""); // drop final period for bullets
        ul.appendChild(el("li", {}, t));
      });
    }

    // Show quotes with “ ”, italics, period at end, tag below, and superscript refs
    function renderQuotes(items = []) {
      const root = qs("#quotes"); root.innerHTML = "";
      const arr = Array.isArray(items) ? items : [];
      if (!arr.length) { root.appendChild(el("div",{class:"muted"},"No quotes returned.")); return; }

      arr.forEach(item => {
        let text="", tag="";
        if (item && typeof item === "object") { text = item.text || item.quote || ""; tag = item.tag || item.respondent || ""; }
        else { text = String(item || ""); }
        const { quote, tag: parsedTag } = splitQuoteAndTag(text);
        if (!tag) tag = parsedTag;

        let qtxt = ensureTerminalPunct(quote);
        qtxt = footnotesToSuperscripts(qtxt);

        const wrap = el("div", { class: "quote-item" }, [
          el("p", { class: "quote-text" }, `“${qtxt}”`),
          tag ? el("div", { class: "quote-tag" }, "— " + tag) : null
        ]);
        root.appendChild(wrap);
      });
    }

    // Try to build a simple satisfaction trend from text if you don't send numeric series.
    function inferTrendFromText({ headline = "", bullets = [] }) {
      const points = [];

      const scan = (s) => {
        const text = String(s || "");
        // examples it will catch: "now at 79%", "79%", "37% in 2024", "in 2023 it's 68%"
        const re = /(?:(now|current|currently|today)|(\d{4}))?[^0-9%]{0,20}(\d{1,3})%/gi;
        let m;
        while ((m = re.exec(text))) {
          const label = m[1] ? "Now" : (m[2] ? m[2] : null);
          const val = Number(m[3]);
          if (label) points.push({ x: label, y: val });
        }
      };

      scan(headline);
      bullets.forEach(scan);

      // unique by label; keep last occurrence
      const map = new Map();
      for (const p of points) map.set(p.x, p.y);
      const uniq = Array.from(map.entries()).map(([x,y]) => ({x,y}));

      // sort by year; keep Now last
      const years = uniq.filter(p => /^\d{4}$/.test(p.x)).sort((a,b)=>Number(a.x)-Number(b.x));
      const now   = uniq.find(p => p.x === "Now");
      const out = years.concat(now ? [now] : []);
      return out.length >= 2 ? out : [];
    }

    function renderChartsFromSeries(series) {
      const grid = qs("#charts");
      grid.innerHTML = "";
      const labels = series.map(p => p.x);
      const values = series.map(p => Number(p.y));

      const card = el("div", { class: "chart-card" }, [
        el("h4", {}, "Satisfaction Trend"),
        el("canvas")
      ]);
      grid.appendChild(card);

      const ctx = card.querySelector("canvas").getContext("2d");
      new Chart(ctx, {
        type: "line",
        data: { labels, datasets: [{ label: "Satisfaction", data: values }] },
        options: {
          responsive: true, maintainAspectRatio: false,
          scales: { y: { beginAtZero: true, ticks: { callback: v => v + "%" } } },
          plugins: { legend: { display: false } }
        }
      });
    }

    function renderVisuals(data) {
      const panel = qs("#visualsPanel");
      const grid  = qs("#charts");

      // First, try explicit numeric series if present
      let numericSeries = [];
      if (Array.isArray(data.visuals)) {
        const s = data.visuals.find(v => Array.isArray(v.points) && v.points.length >= 2);
        if (s) numericSeries = s.points;
      }

      if (!numericSeries.length) {
        // Try to infer from structured headline/bullets
        const s = data.structured || {};
        const headline = (s.headline && s.headline.paragraph) ? s.headline.paragraph : "";
        const bullets  = []
          .concat(Array.isArray(s.headline?.bullets) ? s.headline.bullets : [])
          .concat(Array.isArray(s.supporting) ? s.supporting.map(x=>x.text).filter(Boolean) : []);
        const inferred = inferTrendFromText({ headline, bullets });
        if (inferred.length >= 2) numericSeries = inferred;
      }

      if (!numericSeries.length) {
        // Hide the entire visuals panel if nothing to show
        hide(panel);
        grid.innerHTML = "";
        return;
      }

      show(panel);
      renderChartsFromSeries(numericSeries);
    }

    // References with numbers; show as non-links: “[n] Title”
    function renderRefs(refs = []) {
      const list = qs("#refs"); list.innerHTML = "";
      const arr = Array.isArray(refs) ? refs : [];
      if (!arr.length) { list.appendChild(el("div",{class:"muted"},"No sources returned.")); return; }

      arr.forEach(r => {
        const num = (typeof r.ref === "number" ? r.ref : null);
        const title = niceTitle(r.fileName || "Report");
        const label = num ? `[${num}] ${title}` : title;

        const item = el("div", { class: "ref-item" }, label); // plain text; no <a>
        list.appendChild(item);
      });
    }

    // ---------- fetch/search ----------
    async function runQuery(userQuery) {
      hide(qs("#inlineErr"));

      const token = document.querySelector('meta[name="auth-token"]')?.content || window.AUTH_TOKEN || "";
      const payload = { clientId: "genentech", userQuery, topK: 6 };

      let dataText = "";
      try {
        const res = await fetch("/search", {
          method: "POST",
          headers: { "Content-Type": "application/json", "x-auth-token": token },
          body: JSON.stringify(payload)
        });

        if (!res.ok) {
          const body = await res.text().catch(()=>"");
          console.error("Search failed:", res.status, res.statusText, body);
          qs("#inlineErr").textContent = "Search failed (" + res.status + "). See console for details.";
          show(qs("#inlineErr"));
          return;
        }
        dataText = await res.text();
      } catch (err) {
        console.error("Network error:", err);
        qs("#inlineErr").textContent = "Network error. See console for details.";
        show(qs("#inlineErr"));
        return;
      }

      let data = {};
      try { data = dataText ? JSON.parse(dataText) : {}; }
      catch (e) {
        console.warn("Non‑JSON /search response:", dataText);
        data = {};
      }

      try {
        // Map your 'structured' schema
        const s = data.structured || {};
        const headline = s.headline || {};
        const supportingObjs = Array.isArray(s.supporting) ? s.supporting : [];

        const answer  = headline.paragraph || data.answer || data.summary || data.result || "";
        const bullets = []
          .concat(Array.isArray(headline.bullets) ? headline.bullets : [])
          .concat(supportingObjs.map(o => o?.text).filter(Boolean));

        const quotes  = Array.isArray(s.quotes) ? s.quotes : (data.quotes || []);
        const refs    = data.references || data.refs || [];

        renderAnswer(answer);
        renderBullets(bullets);
        renderQuotes(quotes);
        renderVisuals(data);     // hide panel if nothing chartable
        renderRefs(refs);

        show(qs("#results"));
      } catch (err) {
        console.error("Render error:", err, "Raw data:", data);
        qs("#inlineErr").textContent = "There was an error rendering results. See console for details.";
        show(qs("#inlineErr"));
      }
    }

    // Submit (Enter to submit; Shift+Enter adds a newline)
    document.getElementById("qform").addEventListener("submit", async (e) => {
      e.preventDefault();
      const q = document.getElementById("q").value.trim();
      if (!q) return;
      await runQuery(q);
    });
    document.getElementById("q").addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        document.getElementById("qform").dispatchEvent(new Event("submit"));
      }
    });

    // No auto‑run; panels remain hidden until a question is asked.
  </script>
</body>
</html>
