<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>COGgpt — Research Q&A</title>

  <link rel="stylesheet" href="/styles.css" />
  <!-- Auth token for /search; update if rotated -->
  <meta name="auth-token" content="Jrx4cukgLvuj5jFs4mU0U5ckL+UxHfkrL5pHY+xr5Hw=">

  <!-- Charts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>
<body>
  <div class="page">

    <!-- Header -->
    <header class="header">
      <h1 class="title">
        <span class="title-cog">COG</span><span class="title-gpt">gpt</span>
      </h1>
      <div class="beta-badge">BETA</div>
    </header>

    <!-- Search -->
    <section class="search">
      <form id="qform" autocomplete="off">
        <textarea id="q" rows="3"
          placeholder="Try: “What has satisfaction for Evrysdi looked like over the past few years?”"></textarea>
        <button id="ask" type="submit" title="Ask">Ask</button>
      </form>
      <div id="inlineErr" class="muted hidden"></div>
    </section>

    <!-- Results (hidden until we have results) -->
    <div id="results" class="results hidden">

      <section class="callout" aria-live="polite">
        <div id="answer"></div>
        <ul id="keynums" class="keynums"></ul>
      </section>

      <section class="panel">
        <h3>Supporting Detail</h3>
        <ul id="bullets"></ul>
        <button id="moreBtn" class="link-btn hidden" type="button">Show more</button>
      </section>

      <section id="quotesPanel" class="panel">
        <h3>Supporting Quotes</h3>
        <div id="quotes"></div>
      </section>

      <section id="visualsPanel" class="panel">
        <h3>Visuals</h3>
        <div id="charts" class="charts-grid"></div>
      </section>

      <section class="panel">
        <h3>Report References</h3>
        <ol id="refs" class="ref-ol"></ol>
      </section>
    </div>
  </div>

  <script>
    // ---------- helpers ----------
    const qs  = (s, r=document) => r.querySelector(s);
    const has = (o, k) => Object.prototype.hasOwnProperty.call(o || {}, k);
    const show = el => el && el.classList.remove("hidden");
    const hide = el => el && el.classList.add("hidden");

    function el(tag, attrs = {}, children = []) {
      const node = document.createElement(tag);
      for (const [k, v] of Object.entries(attrs)) {
        if (k === "class") node.className = v;
        else if (k === "html") node.innerHTML = v;
        else node.setAttribute(k, v);
      }
      [].concat(children).forEach(c => {
        if (c === null || c === undefined) return;
        node.appendChild(typeof c === "string" ? document.createTextNode(c) : c);
      });
      return node;
    }

    // ^2^ -> <sup>2</sup> (no brackets, no leading space)
    function caretsToSup(s) {
      return String(s || "").replace(/\s*\^(\d+)\^\s*/g, (_m, n) => `<sup class="ref-sup">${n}</sup>`);
    }

    // ensure period inside quotes; ref superscripts remain outside
    function ensurePeriodInsideQuotes(txt) {
      const t = String(txt || "").trim();
      return /[.!?]$/.test(t) ? t : (t + ".");
    }

    // must look like a real respondent quote: starts with quote and has a trailing tag “— Tag”
    function splitQuoteAndTag(raw) {
      const text = String(raw || "").trim();
      const startsWithQuote = /^["“]/.test(text);
      const inner = text.replace(/^["“]+/, "").replace(/["”]+$/, "");
      const m = inner.match(/^(.*?)(?:\s*[–—-]\s*(.+))?$/);
      return { isQuoted: startsWithQuote, quote: (m ? m[1] : inner).trim(), tag: (m && m[2] ? m[2] : "").trim() };
    }

    function niceTitle(s) { return (s || "").replace(/_/g, " "); }

    // ---------- headline + key numbers ----------
    function renderHeadlineAndKeys(data) {
      const s = data.structured || {};
      const p = s.headline?.paragraph || data.answer || data.summary || data.result || "";
      let html = caretsToSup(p);
      // If headline has no markers, append first ref number so it's sourced
      if (!/\^(\d+)\^/.test(p) && Array.isArray(data.references) && data.references.length) {
        const num = data.references[0]?.ref;
        if (typeof num === "number") html = html.replace(/([.!?])\s*$/, `$1<sup class="ref-sup">${num}</sup>`);
      }
      qs("#answer").innerHTML = html;

      // Key Numbers: take the first 2–3 sourced bullets
      const headBul = Array.isArray(s.headline?.bullets) ? s.headline.bullets : [];
      const supp = Array.isArray(s.supporting) ? s.supporting.map(x=>x.text).filter(Boolean) : [];
      const all = headBul.concat(supp);
      const sourced = all.filter(t => /\^\d+\^/.test(String(t))).slice(0,3);
      const ul = qs("#keynums"); ul.innerHTML = "";
      if (sourced.length) {
        sourced.forEach(t => {
          let txt = String(t).trim().replace(/[.。]\s*$/, "");
          txt = caretsToSup(txt);
          ul.appendChild(el("li", { html: txt }));
        });
        show(ul);
      } else {
        hide(ul);
      }
    }

    // ---------- bullets (top 5 + Show more) ----------
    function renderBullets(data) {
      const ul = qs("#bullets"); ul.innerHTML = "";
      const btn = qs("#moreBtn");
      const s = data.structured || {};
      const headBul = Array.isArray(s.headline?.bullets) ? s.headline.bullets : [];
      const supp = Array.isArray(s.supporting) ? s.supporting.map(x=>x.text).filter(Boolean) : [];
      const all = headBul.concat(supp);

      // keep only bullets with ^n^ markers (sourced)
      const sourced = all.filter(t => /\^\d+\^/.test(String(t)));

      if (!sourced.length) {
        ul.appendChild(el("li",{class:"muted"},"No supporting detail returned."));
        hide(btn);
        return;
      }

      const MAX = 5;
      function liHTML(t){ return caretsToSup(String(t).trim().replace(/[.。]\s*$/, "")); }

      // initial render
      sourced.slice(0, MAX).forEach(t => ul.appendChild(el("li", { html: liHTML(t) })));

      if (sourced.length > MAX) {
        // stash rest; re-render on toggle
        btn._expanded = false;
        btn.onclick = () => {
          btn._expanded = !btn._expanded;
          ul.innerHTML = "";
          const list = btn._expanded ? sourced : sourced.slice(0, MAX);
          list.forEach(t => ul.appendChild(el("li", { html: liHTML(t) })));
          btn.textContent = btn._expanded ? "Show less" : "Show more";
        };
        btn.textContent = "Show more";
        show(btn);
      } else {
        hide(btn);
      }
    }

    // ---------- quotes (respondent only) ----------
    function renderQuotes(data) {
      const panel = qs("#quotesPanel");
      const root = qs("#quotes"); root.innerHTML = "";
      const quotes = (data.structured && Array.isArray(data.structured.quotes) ? data.structured.quotes : (data.quotes || []));

      const filtered = quotes
        .map(q => splitQuoteAndTag(q))
        .filter(x => x.isQuoted && x.tag); // must look like a respondent quote

      if (!filtered.length) { hide(panel); return; }
      show(panel);

      filtered.forEach(({quote, tag}) => {
        const qtxt = ensurePeriodInsideQuotes(quote);   // period inside
        const line = `“${qtxt}”`;                        // close quote
        const html = caretsToSup(line);                 // refs outside (from ^n^ markers)
        const wrap = el("div", { class: "quote-item" }, [
          el("p", { class: "quote-text", html }),
          el("div", { class: "quote-tag" }, "— " + tag)
        ]);
        root.appendChild(wrap);
      });
    }

    // ---------- visuals ----------
    // extract simple 2‑point trends from phrases across text
    function findTrends(text) {
      const out = [];

      // 1) “from X% to Y%”
      const reFromTo = /from\s*(\d{1,3})%\s*to\s*(\d{1,3})%/gi;
      let m;
      while ((m = reFromTo.exec(text))) out.push([{x:"Prev",y:+m[1]},{x:"Now",y:+m[2]}]);

      // 2) “now/at Y%, up from X%”
      const reNowUp = /(now|currently|at)\s*(?:is\s*)?(\d{1,3})%\D{0,30}up\s*(?:from|by)\s*(\d{1,3})%/gi;
      while ((m = reNowUp.exec(text))) out.push([{x:"Prev",y:+m[3]},{x:"Now",y:+m[2]}]);

      // 3) “in 2024 … 68%”, “… 2025 … 79%”
      const years = Array.from(text.matchAll(/(\d{4}).{0,20}?(\d{1,3})%/g))
                         .map(mm => ({x:mm[1],y:+mm[2]}));
      if (years.length >= 2) out.push(years);

      return out;
    }

    function renderCharts(data) {
      const panel = qs("#visualsPanel");
      const grid  = qs("#charts"); grid.innerHTML = "";

      const s = data.structured || {};
      const headP = s.headline?.paragraph || "";
      const textParts = []
        .concat(headP)
        .concat(Array.isArray(s.headline?.bullets) ? s.headline.bullets : [])
        .concat(Array.isArray(s.supporting) ? s.supporting.map(x=>x.text).filter(Boolean) : []);
      const trends = [];

      // explicit numeric series from backend take precedence
      const visuals = Array.isArray(data.visuals) ? data.visuals : [];
      visuals.forEach(v => {
        if (Array.isArray(v.points) && v.points.length >= 2) trends.push(v.points);
      });

      // try to infer from text if no explicit series found
      if (!trends.length) {
        textParts.forEach(t => findTrends(String(t)).forEach(series => trends.push(series)));
      }

      if (!trends.length) { hide(panel); return; }
      show(panel);

      // render up to 2 compact line charts
      trends.slice(0,2).forEach((series, idx) => {
        const labels = series.map(p => p.x);
        const values = series.map(p => Number(p.y));
        const card = el("div", { class: "chart-card" }, [
          el("h4", {}, idx === 0 ? "Trend" : "Trend (2)"),
          el("canvas")
        ]);
        grid.appendChild(card);

        new Chart(card.querySelector("canvas").getContext("2d"), {
          type: "line",
          data: { labels, datasets: [{ label: "", data: values }] },
          options: {
            responsive: true, maintainAspectRatio: false,
            scales: { y: { beginAtZero: true, ticks: { callback: v => v + "%" } } },
            plugins: { legend: { display: false } }
          }
        });
      });
    }

    // ---------- references (ordered, italic, not links) ----------
    function renderRefs(refs = []) {
      const ol = qs("#refs"); ol.innerHTML = "";
      const arr = Array.isArray(refs) ? refs : [];
      if (!arr.length) { ol.appendChild(el("li",{class:"muted"},"No sources returned.")); return; }
      arr.forEach(r => {
        const title = niceTitle(r.fileName || "Report");
        ol.appendChild(el("li", { class: "ref-li" }, title));
      });
    }

    // ---------- fetch/search ----------
    async function runQuery(userQuery) {
      hide(qs("#inlineErr"));

      const token = document.querySelector('meta[name="auth-token"]')?.content || window.AUTH_TOKEN || "";
      const payload = { clientId: "genentech", userQuery, topK: 6 };

      let dataText = "";
      try {
        const res = await fetch("/search", {
          method: "POST",
          headers: { "Content-Type": "application/json", "x-auth-token": token },
          body: JSON.stringify(payload)
        });

        if (!res.ok) {
          const body = await res.text().catch(()=>"");
          console.error("Search failed:", res.status, res.statusText, body);
          qs("#inlineErr").textContent = "Search failed (" + res.status + "). See console for details.";
          show(qs("#inlineErr"));
          return;
        }
        dataText = await res.text();
      } catch (err) {
        console.error("Network error:", err);
        qs("#inlineErr").textContent = "Network error. See console for details.";
        show(qs("#inlineErr"));
        return;
      }

      let data = {};
      try { data = dataText ? JSON.parse(dataText) : {}; }
      catch (e) {
        console.warn("Non‑JSON /search response:", dataText);
        data = {};
      }

      try {
        renderHeadlineAndKeys(data);
        renderBullets(data);
        renderQuotes(data);
        renderCharts(data);
        renderRefs(data.references || data.refs || []);
        show(qs("#results"));
      } catch (err) {
        console.error("Render error:", err, "Raw data:", data);
        qs("#inlineErr").textContent = "There was an error rendering results. See console for details.";
        show(qs("#inlineErr"));
      }
    }

    // Submit (Enter submits; Shift+Enter makes newline)
    document.getElementById("qform").addEventListener("submit", async (e) => {
      e.preventDefault();
      const q = document.getElementById("q").value.trim();
      if (!q) return;
      await runQuery(q);
    });
    document.getElementById("q").addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        document.getElementById("qform").dispatchEvent(new Event("submit"));
      }
    });
  </script>
</body>
</html>
